/**
 * governance.lock File Format
 *
 * The governance.lock file pins policy version to code version, similar to
 * package-lock.json. It is generated by the Policy Compiler and verified
 * by the Supply Chain Firewall in IDE, CI/CD, and runtime.
 *
 * @see I2E_Engine_Specification_v1.md Section 4.2.3
 * @module @aigrc/core/governance-lock
 */

import { z } from "zod";
import * as yaml from "yaml";
import type { AIR, AIRPolicySource } from "../air";

// ─────────────────────────────────────────────────────────────────
// SIGNATURE SCHEMA
// Cryptographic signatures from policy owners
// ─────────────────────────────────────────────────────────────────

export const GovernanceLockSignatureSchema = z.object({
  /** Signer identity (email or system ID) */
  signer: z.string().min(1),
  /** Role of the signer (e.g., "CISO", "PolicyOwner", "SecurityLead") */
  role: z.string().optional(),
  /** Algorithm used: RS256 (RSA-SHA256) or ES256 (ECDSA-P256) */
  algorithm: z.enum(["RS256", "ES256"]),
  /** Base64-encoded signature */
  signature: z.string().min(1),
  /** When the signature was created */
  signed_at: z.string().datetime(),
  /** Key ID for key rotation support */
  key_id: z.string().optional(),
  /** Expiration of this signature (optional, separate from lock expiration) */
  expires_at: z.string().datetime().optional(),
  /** Certificate chain for verification (optional) */
  certificate_chain: z.array(z.string()).optional(),
});

export type GovernanceLockSignature = z.infer<typeof GovernanceLockSignatureSchema>;

// ─────────────────────────────────────────────────────────────────
// POLICY SOURCE REFERENCE SCHEMA
// References to source policy documents with integrity hashes
// ─────────────────────────────────────────────────────────────────

export const GovernanceLockPolicySourceSchema = z.object({
  /** Unique identifier for this source */
  id: z.string().min(1),
  /** Type of source */
  type: z.enum(["pdf", "url", "confluence", "jira", "manual"]),
  /** URI to the source document */
  uri: z.string(),
  /** SHA-256 hash of the source content at time of compilation */
  content_hash: z.string().regex(/^sha256:[a-f0-9]{64}$/),
  /** When the source was fetched */
  fetched_at: z.string().datetime(),
  /** Title of the policy document */
  title: z.string().optional(),
  /** Version of the policy document */
  version: z.string().optional(),
});

export type GovernanceLockPolicySource = z.infer<typeof GovernanceLockPolicySourceSchema>;

// ─────────────────────────────────────────────────────────────────
// COMPILED CONSTRAINTS SCHEMA
// Subset of AIR constraints included in governance.lock
// ─────────────────────────────────────────────────────────────────

export const GovernanceLockRegistryConstraintsSchema = z.object({
  /** List of approved vendor IDs */
  allowed_vendor_ids: z.array(z.string()).default([]),
  /** List of blocked vendor IDs */
  blocked_vendor_ids: z.array(z.string()).default([]),
  /** List of approved region codes */
  allowed_region_codes: z.array(z.string()).default([]),
  /** List of blocked region codes */
  blocked_region_codes: z.array(z.string()).default([]),
  /** List of approved model patterns */
  allowed_model_patterns: z.array(z.string()).default([]),
  /** List of blocked model patterns */
  blocked_model_patterns: z.array(z.string()).default([]),
  /** Maximum model parameters allowed */
  max_model_parameters: z.number().positive().optional(),
});

export type GovernanceLockRegistryConstraints = z.infer<typeof GovernanceLockRegistryConstraintsSchema>;

export const GovernanceLockRuntimeConstraintsSchema = z.object({
  /** Whether PII filtering is required */
  pii_filter_enabled: z.boolean().default(false),
  /** PII filter action */
  pii_filter_action: z.enum(["redact", "block", "warn", "audit"]).optional(),
  /** Whether toxicity filtering is required */
  toxicity_filter_enabled: z.boolean().default(false),
  /** Toxicity threshold */
  toxicity_threshold: z.number().min(0).max(1).optional(),
  /** Data retention period in days */
  data_retention_days: z.number().int().min(0).default(90),
  /** Whether watermarking is required */
  watermark_enabled: z.boolean().default(false),
  /** Logging level */
  logging_level: z.enum(["none", "errors", "all"]).default("all"),
  /** Maximum tokens per request */
  max_tokens_per_request: z.number().int().positive().optional(),
  /** Maximum cost per day in USD */
  max_cost_per_day_usd: z.number().positive().optional(),
  /** Kill switch enabled */
  kill_switch_enabled: z.boolean().default(true),
});

export type GovernanceLockRuntimeConstraints = z.infer<typeof GovernanceLockRuntimeConstraintsSchema>;

export const GovernanceLockBuildConstraintsSchema = z.object({
  /** Require Golden Thread linkage */
  require_golden_thread: z.boolean().default(true),
  /** Require asset card */
  require_asset_card: z.boolean().default(true),
  /** Require risk classification */
  require_risk_classification: z.boolean().default(true),
  /** Require model card */
  require_model_card: z.boolean().default(false),
  /** Require security review for high risk */
  require_security_review: z.boolean().default(false),
  /** Block merge on validation failure */
  block_on_failure: z.boolean().default(true),
  /** Generate SARIF report */
  generate_sarif: z.boolean().default(true),
  /** Allowed environments */
  allowed_environments: z.array(z.string()).default(["development", "staging", "production"]),
});

export type GovernanceLockBuildConstraints = z.infer<typeof GovernanceLockBuildConstraintsSchema>;

export const GovernanceLockConstraintsSchema = z.object({
  /** Registry constraints (vendor/model/region) */
  registry: GovernanceLockRegistryConstraintsSchema.default({}),
  /** Runtime constraints */
  runtime: GovernanceLockRuntimeConstraintsSchema.default({}),
  /** Build constraints */
  build: GovernanceLockBuildConstraintsSchema.default({}),
});

export type GovernanceLockConstraints = z.infer<typeof GovernanceLockConstraintsSchema>;

// ─────────────────────────────────────────────────────────────────
// GOVERNANCE.LOCK SCHEMA
// The complete governance.lock file format
// ─────────────────────────────────────────────────────────────────

export const GovernanceLockSchema = z.object({
  /** Schema version for forward compatibility */
  version: z.literal("1.0"),
  /** When this lock file was generated */
  generated_at: z.string().datetime(),
  /** SHA-256 hash of the compiled policy (AIR) */
  policy_hash: z.string().regex(/^sha256:[a-f0-9]{64}$/),
  /** Name of this policy lock */
  name: z.string().min(1).max(200).optional(),
  /** Description of this lock file */
  description: z.string().max(500).optional(),
  /** Policy sources that contributed to this lock */
  policy_sources: z.array(GovernanceLockPolicySourceSchema).default([]),
  /** Compiled constraints (subset of AIR) */
  constraints: GovernanceLockConstraintsSchema.default({}),
  /** Digital signatures from policy owners */
  signatures: z.array(GovernanceLockSignatureSchema).default([]),
  /** When this lock file expires (forces re-compilation) */
  expires_at: z.string().datetime(),
  /** Tool/system that generated this lock */
  generated_by: z.string().default("aigrc-policy-compiler"),
  /** Version of the generator */
  generator_version: z.string().default("1.0.0"),
  /** Organization this lock belongs to */
  organization: z.string().optional(),
  /** Environment this lock is for */
  environment: z.string().optional(),
  /** Reference to the full AIR document (optional) */
  air_reference: z.object({
    /** AIR document ID */
    id: z.string().uuid(),
    /** AIR document location (URI) */
    location: z.string().optional(),
    /** AIR document hash */
    hash: z.string().regex(/^sha256:[a-f0-9]{64}$/),
  }).optional(),
  /** Custom metadata fields */
  metadata: z.record(z.unknown()).optional(),
});

export type GovernanceLock = z.infer<typeof GovernanceLockSchema>;

// ─────────────────────────────────────────────────────────────────
// VALIDATION RESULT SCHEMA
// Result of validating a governance.lock file
// ─────────────────────────────────────────────────────────────────

export interface GovernanceLockValidationResult {
  /** Whether the lock file is valid */
  valid: boolean;
  /** Validation errors */
  errors: string[];
  /** Validation warnings */
  warnings: string[];
  /** Whether the lock file has expired */
  expired: boolean;
  /** Days until expiration (negative if expired) */
  daysUntilExpiration: number;
  /** Whether signatures are present */
  signed: boolean;
  /** Number of valid signatures */
  validSignatureCount: number;
  /** Whether policy hash is valid */
  policyHashValid: boolean;
}

// ─────────────────────────────────────────────────────────────────
// HELPER FUNCTIONS
// ─────────────────────────────────────────────────────────────────

/**
 * Computes SHA-256 hash of a string
 */
async function computeHash(data: string): Promise<string> {
  // Use Web Crypto API (works in Node.js 18+ and browsers)
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);
  const hashBuffer = await crypto.subtle.digest("SHA-256", dataBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
  return `sha256:${hashHex}`;
}

/**
 * Creates a governance.lock from an AIR document
 */
export async function createGovernanceLock(
  air: AIR,
  options: {
    expiresInDays?: number;
    name?: string;
    description?: string;
    organization?: string;
    environment?: string;
  } = {}
): Promise<GovernanceLock> {
  const now = new Date();
  const expiresAt = new Date(now);
  expiresAt.setDate(expiresAt.getDate() + (options.expiresInDays ?? 30));

  // Compute policy hash from AIR content (excluding signatures)
  const airForHashing = { ...air, signatures: [] };
  const policyHash = await computeHash(JSON.stringify(airForHashing));

  // Extract simplified constraints from AIR
  const constraints: GovernanceLockConstraints = {
    registry: {
      allowed_vendor_ids: air.registry.allowed_vendors.map(v => v.id),
      blocked_vendor_ids: air.registry.blocked_vendors,
      allowed_region_codes: air.registry.allowed_regions.map(r => r.code),
      blocked_region_codes: air.registry.blocked_regions,
      allowed_model_patterns: air.registry.allowed_models.map(m => m.version_pattern ?? m.id),
      blocked_model_patterns: air.registry.blocked_models,
      max_model_parameters: air.registry.max_model_parameters,
    },
    runtime: {
      pii_filter_enabled: air.runtime.pii_filter?.enabled ?? false,
      pii_filter_action: air.runtime.pii_filter?.action,
      toxicity_filter_enabled: air.runtime.toxicity_filter?.enabled ?? false,
      toxicity_threshold: air.runtime.toxicity_filter?.threshold,
      data_retention_days: air.runtime.data_retention_days,
      watermark_enabled: air.runtime.watermark_enabled,
      logging_level: air.runtime.logging_level,
      max_tokens_per_request: air.runtime.max_tokens_per_request,
      max_cost_per_day_usd: air.runtime.max_cost_per_day_usd,
      kill_switch_enabled: air.runtime.kill_switch?.enabled ?? true,
    },
    build: {
      require_golden_thread: air.build.require_golden_thread,
      require_asset_card: air.build.require_asset_card,
      require_risk_classification: air.build.require_risk_classification,
      require_model_card: air.build.require_model_card,
      require_security_review: air.build.require_security_review,
      block_on_failure: air.build.block_on_failure,
      generate_sarif: air.build.generate_sarif,
      allowed_environments: air.build.allowed_environments,
    },
  };

  // Map AIR policy sources to lock format
  const policySources: GovernanceLockPolicySource[] = air.policy_sources.map(s => ({
    id: s.id,
    type: s.type,
    uri: s.uri,
    content_hash: s.content_hash,
    fetched_at: s.fetched_at,
    title: s.title,
    version: s.version,
  }));

  return {
    version: "1.0",
    generated_at: now.toISOString(),
    policy_hash: policyHash,
    name: options.name ?? air.name,
    description: options.description,
    policy_sources: policySources,
    constraints,
    signatures: [],
    expires_at: expiresAt.toISOString(),
    generated_by: air.metadata.generated_by,
    generator_version: air.metadata.compiler_version,
    organization: options.organization ?? air.metadata.organization,
    environment: options.environment ?? air.metadata.environment,
    air_reference: {
      id: air.id,
      hash: policyHash,
    },
  };
}

/**
 * Validates a governance.lock file
 */
export function validateGovernanceLock(
  lock: unknown,
  options: {
    /** Whether to check expiration */
    checkExpiration?: boolean;
    /** Whether to require signatures */
    requireSignatures?: boolean;
    /** Expected policy hash (for integrity check) */
    expectedPolicyHash?: string;
  } = {}
): GovernanceLockValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Parse and validate schema
  const parseResult = GovernanceLockSchema.safeParse(lock);
  if (!parseResult.success) {
    return {
      valid: false,
      errors: parseResult.error.errors.map(e => `${e.path.join(".")}: ${e.message}`),
      warnings: [],
      expired: false,
      daysUntilExpiration: 0,
      signed: false,
      validSignatureCount: 0,
      policyHashValid: false,
    };
  }

  const parsed = parseResult.data;
  const now = new Date();
  const expiresAt = new Date(parsed.expires_at);
  const daysUntilExpiration = Math.ceil((expiresAt.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
  const expired = expiresAt < now;

  // Check expiration
  if (options.checkExpiration !== false && expired) {
    errors.push(`Lock file expired on ${parsed.expires_at}`);
  }

  // Warn if expiring soon (within 7 days)
  if (daysUntilExpiration > 0 && daysUntilExpiration <= 7) {
    warnings.push(`Lock file expires in ${daysUntilExpiration} days`);
  }

  // Check signatures
  const signed = parsed.signatures.length > 0;
  if (options.requireSignatures && !signed) {
    errors.push("Lock file requires at least one signature");
  }

  // Check signature expiration
  let validSignatureCount = 0;
  for (const sig of parsed.signatures) {
    if (sig.expires_at) {
      const sigExpiresAt = new Date(sig.expires_at);
      if (sigExpiresAt < now) {
        warnings.push(`Signature from ${sig.signer} has expired`);
      } else {
        validSignatureCount++;
      }
    } else {
      validSignatureCount++;
    }
  }

  // Check policy hash
  let policyHashValid = true;
  if (options.expectedPolicyHash) {
    if (parsed.policy_hash !== options.expectedPolicyHash) {
      errors.push(`Policy hash mismatch: expected ${options.expectedPolicyHash}, got ${parsed.policy_hash}`);
      policyHashValid = false;
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    expired,
    daysUntilExpiration,
    signed,
    validSignatureCount,
    policyHashValid,
  };
}

/**
 * Parses a governance.lock file from YAML string
 */
export function parseGovernanceLockYAML(content: string): GovernanceLock {
  const parsed = yaml.parse(content);
  return GovernanceLockSchema.parse(parsed);
}

/**
 * Parses a governance.lock file from JSON string
 */
export function parseGovernanceLockJSON(content: string): GovernanceLock {
  const parsed = JSON.parse(content);
  return GovernanceLockSchema.parse(parsed);
}

/**
 * Serializes a governance.lock to YAML
 */
export function serializeGovernanceLockYAML(lock: GovernanceLock): string {
  return yaml.stringify(lock, {
    indent: 2,
    lineWidth: 120,
  });
}

/**
 * Serializes a governance.lock to JSON
 */
export function serializeGovernanceLockJSON(lock: GovernanceLock, pretty = true): string {
  return pretty ? JSON.stringify(lock, null, 2) : JSON.stringify(lock);
}

/**
 * Checks if a governance.lock file is expired
 */
export function isGovernanceLockExpired(lock: GovernanceLock): boolean {
  return new Date(lock.expires_at) < new Date();
}

/**
 * Gets the number of days until a governance.lock expires
 */
export function getDaysUntilExpiration(lock: GovernanceLock): number {
  const now = new Date();
  const expiresAt = new Date(lock.expires_at);
  return Math.ceil((expiresAt.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
}

/**
 * Checks if a vendor is allowed by the governance.lock
 */
export function isVendorAllowedByLock(vendorId: string, lock: GovernanceLock): boolean {
  const { registry } = lock.constraints;

  // Check blocked list first
  if (registry.blocked_vendor_ids.includes(vendorId)) {
    return false;
  }

  // Check allowed list (if specified)
  if (registry.allowed_vendor_ids.length > 0) {
    return registry.allowed_vendor_ids.includes(vendorId);
  }

  // If no allowed list, allow by default (except blocked)
  return true;
}

/**
 * Checks if a model is allowed by the governance.lock
 */
export function isModelAllowedByLock(modelId: string, lock: GovernanceLock): boolean {
  const { registry } = lock.constraints;

  // Check blocked patterns
  for (const pattern of registry.blocked_model_patterns) {
    if (matchesPattern(modelId, pattern)) {
      return false;
    }
  }

  // Check allowed patterns (if specified)
  if (registry.allowed_model_patterns.length > 0) {
    return registry.allowed_model_patterns.some(pattern =>
      matchesPattern(modelId, pattern)
    );
  }

  // If no allowed list, allow by default (except blocked)
  return true;
}

/**
 * Checks if a region is allowed by the governance.lock
 */
export function isRegionAllowedByLock(regionCode: string, lock: GovernanceLock): boolean {
  const { registry } = lock.constraints;

  // Check blocked list first
  if (registry.blocked_region_codes.includes(regionCode)) {
    return false;
  }

  // Check allowed list (if specified)
  if (registry.allowed_region_codes.length > 0) {
    return registry.allowed_region_codes.includes(regionCode);
  }

  // If no allowed list, allow by default (except blocked)
  return true;
}

/**
 * Simple pattern matching (supports wildcards)
 */
function matchesPattern(value: string, pattern: string): boolean {
  if (pattern === "*") {
    return true;
  }
  if (pattern.endsWith("*")) {
    return value.startsWith(pattern.slice(0, -1));
  }
  if (pattern.startsWith("*")) {
    return value.endsWith(pattern.slice(1));
  }
  return value === pattern;
}

/**
 * Creates a canonical string for signing
 */
export function createSigningPayload(lock: GovernanceLock): string {
  // Create a deterministic representation excluding signatures
  const forSigning = {
    version: lock.version,
    generated_at: lock.generated_at,
    policy_hash: lock.policy_hash,
    expires_at: lock.expires_at,
    constraints: lock.constraints,
  };
  return JSON.stringify(forSigning);
}

/**
 * Adds a signature to a governance.lock
 * Note: Actual cryptographic signing is delegated to external libraries
 */
export function addSignature(
  lock: GovernanceLock,
  signature: GovernanceLockSignature
): GovernanceLock {
  return {
    ...lock,
    signatures: [...lock.signatures, signature],
  };
}

/**
 * Computes a hash for integrity verification
 */
export { computeHash };
